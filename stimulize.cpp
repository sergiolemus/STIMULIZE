#include <cinttypes>
#include <cstdlib>
#include <iostream>
#include <string>
#include <regex>
#include <vector>

#define VERSION "v3.41"

// PROGRAM TO VECTORIZE IRSIM INPUTS

// REQUIRED FLAGS:
// --analyzer,-a <nodes...>       :   ENTER SPACE SEPARATED NODE NAMES
// --vector,-v <nodes...>         :   ENTER SPACE SEPARATED NODE NAMES TO VECTORIZE

// OPTIONAL FLAGS:
// --stepsize,-s <val>            :   SET STEPSIZE TO VAL ns, DEFAULT IS 5ns
// --test,-t <val_sequence...>    :   ENTER A TEST SEQUENCE OF VALUES

// EXAMPLE: 2 INPUT AND WITH (A,B) AS INPUTS AND (OUT) AS AN OUTPUT
// (A,B) WILL GO RESPECTIVELY FROM (0,0) -> (0,1) -> (1,0) -> (1,1)
// WITH A STEPSIZE OF 5ns.

// ./stimulize -analyzer A B OUT -v A B

// EXAMPLE: (IN_1,IN_2,IN_3) AS INPUTS AND (OUT_1,OUT_2) AS OUTPUTS
// (IN_1,IN_2,IN_3) WILL GO RESPECTIVELY FROM (0,0,0) -> (0,0,1) -> ... -> (1,1,0) -> (1,1,1)
// WITH A STEPSIZE OF 10ns

//./stimulize -a IN_1 IN_2 IN_3 OUT_A OUT_B -v IN_1 IN_2 IN_3 -s 10

//function to convert a binary number to grays code
//counting sequentially in gray code only toggles 1 bit at a time so should give more stable output shapes
template <class T>
T binaryToGray( T bnum )
{
    return ( ( bnum ) ^ ( bnum >> 1 ) );
}

// FUNCTION TO INSPECT THE STATE VECTOR AS A COMMENT
void printState( const std::vector<std::string> &inputs, int v_nodes, unsigned int number,
                 const std::string &sequence )
{
    std::string binary = "";
    
    std::cout << "| VECTOR: [";
    
    v_nodes--;
    for( int i = 0; i < v_nodes; i++ )
    {
        std::cout << inputs[ i ] << ",";
    }
    
    std::cout << inputs[ v_nodes ] << "] = [";
    
    if( sequence == "" )
    {
        if( number & 1 )
        {
            binary = "1";
        }
        else
        {
            binary = "0";
        }
    
        number = number >> 1;
    
        v_nodes++;
        for( int i = 1; i < v_nodes; i++ )
        {
            if( number & 1 )
            {
                binary = "1," + binary;
            }
            else
            {
                binary = "0," + binary;
            }
            
            number = number >> 1;
        }
        
        std::cout << binary;
    }
    else
    {
        for( int i = 0; i < v_nodes; i++ )
        {
            std::cout << sequence[ i ] << ",";
        }
        
        std::cout << sequence[ v_nodes ];
    }
    
    std::cout << "]\n";
}

// FUNCTION TO GENERATE VECTORIZED INPUTS
//"DRIVER" that is run by main after error checking
int generateCommands( const std::vector<std::string> &argv, int a_index, int a_nodes, 
                       int v_index, int v_nodes, int t_index, int t_nodes, bool t, int s_index )
{

//  auto make_time = std::chrono::system_clock::now();
    std::cout << "| STIMULIZE " << VERSION << std::endl
              << "| FILE GENERATED BY COMMAND:\n | ";

    for ( int i = 0; i < argv.size(); i++ )
    {
        std::cout << argv[ i ] << " ";
    }
    std::cout << "\n\n";

    std::vector<std::string> inputs      ( v_nodes );
    std::vector<char>        input_values( v_nodes );
    std::vector<bool>        toggle      ( v_nodes );
    
    bool low = false;
    bool high = false;
    
    if( s_index == -1 )
    {
        std::cout << "stepsize 5\n";
    }
    else
    {
        std::cout << "stepsize " << argv[ s_index + 1 ] << "\n";
    }
    
    a_index++;
    std::cout << "analyzer ";
    for( int i = 0; i < a_nodes; i++ )
    {
        std::cout << argv[ a_index + i ] << " ";
    }
    std::cout << "\n\n" << std::flush;
    
    v_index++;
    for( int i = 0; i < v_nodes; i++ )
    {
        inputs[ i ] = argv[ v_index + i ];
        input_values[ i ] = 0;
        toggle[ i ] = true;
    }
    
    //default sequence (count through all combinations in gray)
    //works by counting up all states as a binary/gray number, then masking and putting in inputs[n]
    if( !t )
    {        
        std::uint_least64_t count_to = 1;

        for ( int i = 0; i < v_nodes; i++ )
        {
            count_to *= 2;
        }

        if ( count_to == 0 )
        {
            std::cerr << "Too many vectorized inputs" << std::endl;
            return 2;
        }

        //print first state
        printState( inputs, v_nodes, 0, "" );
        
        std::cout << "l ";
        for( int n = 0; n < v_nodes; n++ )
        {
            std::cout << inputs[ n ] << " ";
        }
        std::cout << "\ns" << ( count_to == 1 ? "": "\n\n");

        //print sequential states states
        for( auto bnum = 1; bnum < count_to; bnum++ )
        {
            auto gnum = binaryToGray( bnum );

            low = false;
            high = false;

            printState( inputs, v_nodes, gnum, "" );
            
            for( int n = v_nodes - 1; n >= 0; n-- )
            {
                //count in binary
                //if( ( ( bnmum & mask ) >> ( shift_right ) != input_values[ n ] ) )

                //count in gray code
                if( ( gnum & 1 ) != input_values[ n ] )
                {
                    toggle[ n ] = true;
                    
                    if( !low && input_values[ n ] == 1 )
                    {
                        low = true;
                    }
                    else if( !high && input_values[ n ] == 0 )
                    {
                        high = true;
                    }
                }
                else
                {
                    toggle[ n ] = false;
                }

                gnum = gnum >> 1;
            }
            
            if( low )
            {
                std::cout << "l ";
                
                for( int n = 0; n < v_nodes; n++ )
                {
                    if( toggle[ n ] && ( input_values[ n ] == 1 ) )
                    {
                        toggle[ n ] = false;
                        input_values[ n ] = 0;
                        std::cout << inputs[ n ] << " ";
                    }
                }
                
                std::cout << "\n";
            }
            
            if( high )
            {
                std::cout << "h ";
                
                for( int n = 0; n < v_nodes; n++ )
                {
                    if( toggle[ n ] && ( input_values[ n ] == 0 ) )
                    {
                        toggle[ n ] = false;
                        input_values[ n ] = 1;
                        std::cout << inputs[ n ] << " ";
                    }
                }
                
                std::cout << "\n";
            }
            
            std::cout << "s\n\n";
        }
        
        printState( inputs, v_nodes, 0, "" );
        
        //end by making all inputs low
        std::cout << "l ";

        for( int n = 0; n < v_nodes; n++ )
        {
            std::cout << inputs[ n ] << " ";
            input_values[ n ] = 0;
        }
        std::cout << "\ns";
    }
    
    //custom test sequence
    //works by explictly maniplating the input_values[n]
    else
    {
        std::string arg;
        
        t_index++;
        arg = std::string( argv[ t_index ] );
        for( int n = 0; n < v_nodes; n++ )
        {
            //convert from ascii representation of "0"/"1" to "0"/"1"
            input_values[ n ] = arg[ n ] - 0x30;
            
            if( !low && input_values[ n ] == 0 )
            {
                low = true;
            }
            else if( !high && input_values[ n ] == 1 )
            {
                high = true;
            }
        }
        
        printState( inputs, v_nodes, 0, arg );
        
        if( low )
        {
            std::cout << "l ";
            
            for( int n = 0; n < v_nodes; n++ )
            {
                if( input_values[ n ] == 0 )
                {
                    std::cout << inputs[ n ] << " ";
                }
            }
            
            std::cout << "\n";
        }
        
        if( high )
        {
            std::cout << "h ";
            
            for( int n = 0; n < v_nodes; n++ )
            {
                if( input_values[ n ] == 1 )
                {
                    std::cout << inputs[ n ] << " ";
                }
            }
            
            std::cout << "\n";
        }
        
        std::cout << "s" << ( t_nodes == 1 ? "": "\n\n");

        for( int i = 1; i < t_nodes; i++ )
        {
            low = false;
            high = false;
            
            arg = std::string( argv[ t_index + i ] );
            for( int n = 0; n < v_nodes; n++ )
            {
                if( (arg[ n ] - 48) != input_values[ n ] )
                {
                    toggle[ n ] = true;
                    
                    if( !low && input_values[ n ] == 1 )
                    {
                        low = true;
                    }
                    else if( !high && input_values[ n ] == 0 )
                    {
                        high = true;
                    }
                }
                else
                {
                    toggle[ n ] = false;
                }
            }
            
            printState( inputs, v_nodes, 0, arg );
            
            if( low )
            {
                std::cout << "l ";
                
                for( int n = 0; n < v_nodes; n++ )
                {
                    if( toggle[ n ] && input_values[ n ] == 1 )
                    {
                        toggle[ n ] = false;
                        input_values[ n ] = 0;
                        std::cout << inputs[ n ] << " ";
                    }
                }
                
                std::cout << "\n";
            }
            
            if( high )
            {
                std::cout << "h ";
                
                for( int n = 0; n < v_nodes; n++ )
                {
                    if( toggle[ n ] && input_values[ n ] == 0 )
                    {
                        toggle[ n ] = false;
                        input_values[ n ] = 1;
                        std::cout << inputs[ n ] << " ";
                    }
                }
                
                std::cout << "\n";
            }
            
            std::cout << "s" << ( i == ( t_nodes - 1 ) ? "" : "\n\n" );
        }
    }
    std::cout << std::flush;
    return 0;
}

void show_usage()
{
    std::cerr << std::endl
              << "Usage:\n\n"
              << "stimulize -a {node_name ..} -v {node_name ..} "
              << "[-s <step_val>] [-t {test_seq ..}]\n\n" 
    
              << "Required:\n\n" 
              << "  -a,--analyzer {node_name ..}          "
              << "nodes to view on the analyzer window.\n"
              << "  -v,--vector {node_name ..}            "
              << "nodes to vectorize.\n" 
    
              << "Optional:\n" 
              << "  -s,--stepsize <step_val>              "
              << "set the stepsize to <step_val>, default is 5ns.\n" 
              << "  -t,--test {test_seq ..}               "
              << "binary sequences to test on vector.\n"
              << "                                        "
              << "default is all combinations through gray code\n\n" 

              << "Examples:\n" 
              << "  stepsize: 5ns, analyzer: [A,B,C,OUT], vector: [A,B,C], all combinations, gray code\n\n"
              << "$ stimulize -a A B C OUT -v A B\n"
              << "  stepsize: 50ns, analyzer: [I0,I1,I2,I3,O0,O1], vector: [I0,I1,I2,I3] = [0,0,0,0] [1,1,1,0] [0,0,1,1] [1,1,1,1]\n"
              << "$ stimulize -a I0 I1 I2 I3 O0 O1 -v I0 I1 I2 I3 -t 0000  1110  0011 1111 > test.cmd\n\n"
              << "If this program isinstalled on your system, use \n"
              << "$ man stimulize\n"
              << "for more / better formatted details\n\n" << std::flush;
}

//error checks inputs, then passes to "generateCommands"
int main( int argc, char** argv )
{
    int analyzer_index = -1;
    int analyzer_nodes = 0;
    bool analyzer = false;
    
    int vector_index = -1;
    int vector_nodes = 0;
    bool vector = false;
   
    int stepsize_index = -1;
    int stepsize_nodes = 0;
    bool stepsize = false;
    
    int test_index = -1;
    int test_nodes = 0;
    bool test = false;
    
    std::string flag = "";
    std::string arg;
    int count;
    
    bool error = false;
    
    //arguments are transfered from argv to argv_v to allow for expansion
    //count and store how many arguments there are for analyzer nodes, v nodes, etc
    std::vector<std::string> argv_v;
    
    std::regex expand(".*\\[\\d+:\\d+\\]");
    std::regex number ("\\d+");

    if( argc == 1 )
    {
        show_usage( );
        exit( 1 );
    }
    argv_v.push_back( argv[ 0 ] );

    //walk through each argument, verify if it is a flag or another argument,
    //update indicies for analyzer,vector,step,test, etc, and copy all to argv_v
    for( int i = 1; i < argc; i++ )
    {

        arg = std::string( argv[ i ] );

        //if input is of form NAME[0:100]
        //expand to  NAME0 NAME1 .... NAME1000
        if ( std::regex_match( arg, expand ) )
        {
            
            std::sregex_iterator next(arg.begin(), arg.end(), number);
            
            std::smatch match = *next;
            int first = std::stoi( match.str() );

            next++;
            match = *next;
            
            int second = std::stoi( match.str() );

            std::string name = arg.substr( 0, arg.find("[") );

            if ( first <= second )
            {
                for ( int i = first; i <= second; i++ )
                {
                    argv_v.push_back( name + std::to_string( i ) );
                    count++;
                }
            }

            else
            {
                for ( int i = first; i >= second; i-- )
                {
                    argv_v.push_back( name + std::to_string( i ) );
                    count++;
                }
            }
            count--;
        }
        else
        {
            argv_v.push_back( arg );
        }

        if( arg == "-a" || arg == "--analyzer" )
        {
            analyzer_index = argv_v.size() - 1;
            
            if( analyzer == true )
            {
                std::cerr << "--analyzer, -a: Ocurred too many times\n";
                error = true;
            }
            
            analyzer = true;
            
            if( flag == "v" )
            {
                vector_nodes = count;
            }
            else if( flag == "t" )
            {
                test_nodes = count;
            }
            else if( flag == "s" )
            {
                stepsize_nodes = count;
            }
            
            flag = "a";
            count = -1;
        }
        else if( arg == "-v" || arg == "--vector" )
        {
            vector_index = argv_v.size() - 1;
            
            if( vector == true )
            {
                std::cerr << "--vector, -v: Ocurred too many times\n";
                error = true;
            }
            
            vector = true;
            
            if( flag == "a" )
            {
                analyzer_nodes = count;
            }
            else if( flag == "t" )
            {
                test_nodes = count;
            }
            else if( flag == "s" )
            {
                stepsize_nodes = count;
            }
            
            flag = "v";
            count = -1;
        }
        else if( arg == "-t" || arg == "--test" )
        {
            test_index = argv_v.size() - 1;
            
            if( test == true )
            {
                std::cerr << "--test, -t: Ocurred too many times\n";
                error = true;
            }
            
            test = true;
            
            if( flag == "a" )
            {
                analyzer_nodes = count;
            }
            else if( flag == "v" )
            {
                vector_nodes = count;
            }
            else if( flag == "s" )
            {
                stepsize_nodes = count;
            }
            
            flag = "t";
            count = -1;
        }
        else if( arg == "-s" || arg == "--stepsize" )
        {
            stepsize_index = argv_v.size() - 1;
            
            if( stepsize == true )
            {
                std::cerr << "--stepsize, -s: Ocurred too many times\n";
                error = true;
            }
            
            stepsize = true;
            
            if( flag == "a" )
            {
                analyzer_nodes = count;
            }
            else if( flag == "v" )
            {
                vector_nodes = count;
            }
            else if( flag == "t" )
            {
                test_nodes = count;
            }
            
            flag = "s";
            count = -1;
        }
        else if( arg[ 0 ] == '-' )
        {
            show_usage();
            return 1;
        }
        count++;
    }
    
    if( flag == "v" )
    {
        vector_nodes = count;
    }
    else if( flag == "t" )
    {
        test_nodes = count;
    }
    else if( flag == "a" )
    {
        analyzer_nodes = count;
    }
    else if( flag == "s" )
    {
        stepsize_nodes = count;
    }
    
    if( !analyzer )
    {
        std::cerr << "--analyzer, -a: Flag required.\n";
        error = true;
    }
    
    if( !vector )
    {
        std::cerr << "--vector, -v: Flag required.\n";
        error = true;
    }
    
    if( analyzer && analyzer_nodes == 0 )
    {
        std::cerr << "--analyzer, -a: No nodes submitted.\n";
        error = true;
    }
    
    if( vector && vector_nodes == 0 )
    {
        std::cerr << "--vector, -v: No nodes submitted.\n";
        error = true;
    }
    
    bool non_binary  = false;
    
    //if running a custom test sequence, verify it is valid
    if( test )
    {
        if( test_nodes == 0 )
        {
            std::cerr << "--test, -t: No test sequence submitted.\n";
            error = true;
        }
    
        for( int i = 0; i < test_nodes; i++ )
        {
            arg = std::string( argv_v[ (test_index + 1) + i ] );
            if( arg.length() != vector_nodes )
            {
                std::cerr << "--test, -t: Sequence (" << i+1 << ")";
                std::cerr << " contains (" << arg.length() << "), not (" << vector_nodes << ") values: ";
                std::cerr << arg << '\n';
                error = true;
            }
            
            non_binary = false;
            
            for( int c = 0; c < arg.length(); c++ )
            {
                if( arg[ c ] != '0' && arg[ c ] != '1' )
                {
                    if( !non_binary )
                    {
                        std::cerr << "--test, -t: Sequence (" << i+1 << ")";
                        std::cerr << " contains non-binary character(s): ";
                        
                        non_binary = true;
                    }
                    
                    std::cerr << arg[c];
                    error = true;
                }
            }
            
            if( non_binary )
            {
                std::cerr << std::endl;
            }
        }
    }
    
    if(  stepsize && stepsize_nodes == 0 )
    {
        std::cerr << "--stepsize, -s: No value submitted.\n";
        error = true;
    }
    
    if( stepsize && stepsize_nodes > 1 )
    {
        std::cerr << "--stepsize, -s: More than one value was passed in.\n";
        error = true;
    }
    
    if( error )
    {
        std::cerr << "If this program is installed on your system, use \n"
                  << "$ man stimulize\n"
                  << "for more details\n" << std::flush;
        return 1;
    }
    
    return generateCommands( argv_v, analyzer_index, analyzer_nodes, vector_index, vector_nodes,
                     test_index, test_nodes, test, stepsize_index );
    
}