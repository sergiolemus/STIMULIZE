.\" Manpage for stimulize.
.\" Create a git pull request at https://github.com/sergiolemus/stimulize 
.TH man 1 "28 March 2019" "1.0" "STIMULIZE User Manual"
.SH NAME
.B stimulize 
\- create 
.I irsim 
command scripts to test logic circuits easily and programmatically.

.SH SYNOPSIS
.B stimulize 
-h[elp]
.br
.B stimulize
-a[nalyzer] {a_nodes} -v[ector] {v_nodes} [options]

.SH DESCRIPTION
.I stimulize
creates an irsim cmd format from given inputs. It will display {a_nodes} on the analyzer window
and will step through input combinations of {v_nodes}. The output of the program is written
to stdout can be piped to a file and then imported to either standalone, terminal
.I irsim
or 
.I GNU Electric irsim 
(available in the SFS extension) easily.

.SH OPTIONS
If no 
.I stepsize 
is given, the default is set to 5(ns). If no test sequence is provided, the program will
automatically step through all combinations of {v_nodes} through gray code sequence.
.br
.PP
.TP
.IR \-a " " a_nodes
List which nodes should be printed on the analyzer window. Arguments should be space seperated
.br
Node lists may be given in format NAME[<num1>:<num2>] and will be auto expanded. See Example 3
.TP
.IR \-h
help
.TP
.IR \-s " " stepsize
step size, in nanoseconds. If no argument is given, defaults to 5ns
.TP
.IR \-t " " test_sequence
Test sequency, in binary. You can feed the program a sequence of N-bit binary numbers, where
N is the number of v_nodes there are. Arguments should be space seperated. 
.br
If no sequence is given, the program will step through every N bit combination through gray code
sequence such that only 1 bit changes during each step.
.TP
.IR \-v " " v_nodes
List which nodes will be controlled as a vector input to the circuit. Arguments should be space seperated
.br
Node lists may be given in format NAME[<num1>:<num2>] and will be auto expanded. See Example 3

.SH EXAMPLES
.PP
.br
Stepsize: default - 5ns, View [A,B,C,OUT] in the analyzer, Vectorize [A,B,C] as inputs, and step through all combinations in
gray code order.
.br
\fI% stimulize \-a A B C OUT \-v A B C\fR
.br
| STIMULIZE v3.01
.br
| FILE GENERATED BY COMMAND:
.br
| stimulize -a A B C OUT -v A B C 
.br
stepsize 5
.br
analyzer A B C OUT 
.br
| VECTOR: [A,B,C] = [0,0,0]
.br
l A B C
.br
s
.br
| VECTOR: [A,B,C] = [0,0,1]
.br
h C 
.br
s
.br
| VECTOR: [A,B,C] = [0,1,1]
.br
h B 
.br
s
.br
| VECTOR: [A,B,C] = [0,1,0]
.br
l C 
.br
s
.br
| VECTOR: [A,B,C] = [1,1,0]
.br
h A 
.br
s
.br
| VECTOR: [A,B,C] = [1,1,1]
.br
h C 
.br
s
.br
| VECTOR: [A,B,C] = [1,0,1]
.br
l B 
.br
s
.br
| VECTOR: [A,B,C] = [1,0,0]
.br
l C 
.br
s
.br
| VECTOR: [A,B,C] = [0,0,0]
.br
l A B C 
.br
s
.PP
Stepsize: 50ns, View [I0,I1,I2,I3,O0,O1] in the analyzer, Vectorize [I0,I1,I2,I3] as inputs, and step through
the specific specific cases:
.br
[I0,I1,I2,I3] = [0,0,0,0], [1,1,1,0], [0,0,1,1], [1,1,1,1].
.br
\fI% stimulize \-a I0 I1 I2 I3 O0 O1 \-v I0 I1 I2 I3 -s 50 -t 0000 1110 0011 1111\fR
.br
| STIMULIZE v3.01
.br
| FILE GENERATED BY COMMAND:
.br
| stimulize -a I0 I1 I2 I3 O0 O1 -v I0 I1 I2 I3 -s 50 -t 0000 1110 0011 1111 
.br
stepsize 50
.br
analyzer I0 I1 I2 I3 O0 O1 
.br
| VECTOR: [I0,I1,I2,I3] = [0,0,0,0]
.br
l I0 I1 I2 I3 
.br
s
.br
| VECTOR: [I0,I1,I2,I3] = [1,1,1,0]
.br
h I0 I1 I2 
.br
s
.br
| VECTOR: [I0,I1,I2,I3] = [0,0,1,1]
.br
l I0 I1 
.br
h I3 
.br
s
.br
| VECTOR: [I0,I1,I2,I3] = [1,1,1,1]
.br
h I0 I1 
.br
s
.PP
Stepsize: 50ns, View [A3,A2,A1,A0,B3,B2,B1,B0,F3,F2,F1,F0] in the analyzer, Vectorize [A3,A2,A1,A0,B3,B2,B1,B0] as inputs, 
and step through specific cases
.br
[A3,A2,A1,A0,B3,B2,B1,B0]=[0,0,0,0,0,0,0,0], [1,1,1,1,0,0,0,0,], [0,0,0,0,1,1,1,1]
.br
\fI%stimulize -a A[3:0] B[3:0] F[3:0] -v A[3:0] B[3:0] -s 50 -t 00000000 11110000 00001111\fR
.br
| STIMULIZE v3.41
.br
| FILE GENERATED BY COMMAND:
.br
| ./stimulize -a A3 A2 A1 A0 B3 B2 B1 B0 F3 F2 F1 F0 -v A3 A2 A1 A0 B3 B2 B1 B0 -s 50 -t 00000000 11110000 00001111 
.br
stepsize 50
.br
analyzer A3 A2 A1 A0 B3 B2 B1 B0 F3 F2 F1 F0 
.br
| VECTOR: [A3,A2,A1,A0,B3,B2,B1,B0] = [0,0,0,0,0,0,0,0]
.br
l A3 A2 A1 A0 B3 B2 B1 B0 
.br
s
.br
| VECTOR: [A3,A2,A1,A0,B3,B2,B1,B0] = [1,1,1,1,0,0,0,0]
.br
h A3 A2 A1 A0 
.br
s
.br
| VECTOR: [A3,A2,A1,A0,B3,B2,B1,B0] = [0,0,0,0,1,1,1,1]
.br
l A3 A2 A1 A0 
.br
h B3 B2 B1 B0 
.br
s

.SH Todo's / Known Bugs
1) Allow test sequences to be written in hex
.br
2) Because default test sequences are stored as ints, systems with 64 or more inputs are not processed correctly
The step to correct this would be to make a function that can take in a raw bool vector and automatically increment
in binary or gray code but it currently seems unnecessary.

.SH AUTHOR
2019 Segio Lemus, Joseph Shaker.
.br
Please make all inquiries or bug reports on the github page.
.br
https://github.com/sergiolemus/stimulize
.PP
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
.br
* Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.
.br
* Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.
.br
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.